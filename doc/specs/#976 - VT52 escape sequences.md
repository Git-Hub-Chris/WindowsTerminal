---
author: James Holderness @j4james
created on: 2019-07-17
last updated: 2019-07-17
issue id: 976
---

# VT52 Escape Sequences

## Abstract

This spec outlines the work required to split off the existing VT52 commands from the VT100 implementation, and extend the VT52 support to cover all of the core commands.

## Inspiration

The existing VT52 commands aren't currently implemented as a separate mode, so they conflict with sequences defined in the VT100 specification. This is blocking us from adding support for the VT100 Index (IND) escape sequence, which is one of the missing commands required to pass the test of cursor movements in Vttest.

## Solution Design

The basic idea is to add support for the [DECANM private mode sequence](https://vt100.net/docs/vt100-ug/chapter3.html#DECANM), which can then be used to switch from the default _ANSI_ mode, to a new _VT52_ mode.

In terms of implementation, there are a number of areas of the system that would need to be updated.

### The State Machine

In order to implement the VT52 compatibility mode correctly, we'll need to introduce a flag in the `StateMachine` class that indicates the mode that is currently active. When in VT52 mode, certain paths in the state diagram should not be followed - for example, you can't have CSI, OSC, or SS3 escape sequences. There would also need to be an additional state to handle VT52 parameters (for the _Direct Cursor Address_ command). These parameters take a different form to the typical VT100 parameters, as they follow the command character instead of preceding it.

It would probably be best to introduce a new dispatch method in the `IStateMachineEngine` interface to handle the parsed VT52 sequences, since the existing `ActionEscDispatch` does not support parameters (which are required for the _Direct Cursor Address_ command). I think it would also make for a cleaner implementation to have the VT52 commands separate from the VT100 code, and would likely have less impact on the performance that way.

### The Terminal Input

The escape sequences generated by the keyboard for function keys, cursor keys, and the numeric keypad, are not the same in VT52 mode as they are in ANSI mode. So there would need to be a flag in the `TerminalInput` class to keep track of the current mode, and thus be able to generate the appropriate sequences for that mode.

Technically the VT52 keyboard doesn't map directly to a typical PC keyboard, so we can't always work from the specs in deciding what sequences are required for each key. When in doubt, we should probably be trying to match the key sequences generated by XTerm.

### Changing Modes

The `_PrivateModeParamsHelper` method in the `AdaptDispatch` class would need to be extended to handle the DECANM mode parameter, and trigger a function to switch to VT52 mode. The typical pattern for this seems to be through a `PrivateXXX` method in the `ConGetSet` interface. Then the `ConhostInternalGetSet` implementation can pass that flag on to the active output buffer's `StateMachine`, and the active input buffer's `TerminalInput` instance.

Changing back from VT52 mode to ANSI mode would need to be achieved with a separate VT52 command, since the VT100 CSI mode sequences would no longer be active. This would be handled in the same place as the other VT52 commands, in the `OutputStateMachineEngine`, and then passed on to the mode selection method in the `AdaptDispatch` class described above (essentially the equivalent of the DECANM private mode being set).

### Additional VT52 Commands

Most of the missing VT52 functionality can be implemented in terms of existing VT100 methods.
 
* The _Cursor Up_, _Cursor Down_, _Cursor Left_, and _Cursor Right_ commands are already implemented.
* The _Enter Graphics Mode_ and _Exit Graphics Mode_ commands can probably use the existing `DesignateCharset` method, although this would require a new `VTCharacterSets` option with a corresponding table of characters (see below).
* The _Reverse Line Feed_ command can use the existing `ReverseLineFeed` method.
* The _Erase to End of Display_ and _Erase to End of Line_ commands can use the existing `EraseInDisplay` and `EraseInLine` methods.
* The _Cursor Home_ and _Direct Cursor Address_ commands can probably be implemented using the `CursorPosition` method. Technically the _Direct Cursor Address_ has different rules for the boundary conditions, but nobody seems to get that right, so it's probably not that big a deal.
* The _Identify_ command may be the only one that doesn't build on existing functionality, but it should be a fairly trivial addition to the `AdaptDispatch` class.
* The _Enter Keypad Mode_ and _Exit Keypad Mode_ commands can use the existing `SetKeypadMode` method, assuming the `Terminal Input` class already knows to generate different sequences when in VT52 mode.
* The _Enter ANSI Mode_ command can just call through to the new mode selection method in the `AdaptDispatch` class as discussed in the _Changing Modes_ section above.

There are also a few VT52 print commands, but those are not technically part of the core command set, so they can probably be considered out of scope for now.

### Graphic Mode Character Set

The table below lists suggested mappings for the _Graphics Mode_ character set, based on the descriptions in the [VT102 User Guide](https://vt100.net/docs/vt102-ug/table5-15.html).

Note that there is only the one _fraction numerator_ character in Unicode, so superscript digits have instead been used for the numerators 3, 5, and 7. There are also not enough _horizontal scan line_ characters (for the _bar at scan x_ characters), so each of them is used twice to cover the full range.

ASCII Character	|Mapped Glyph   |Unicode Value  |Spec Description
----------------|---------------|---------------|----------------
_               |               |U+0020         |Blank
`               |               |U+0020         |Reserved
a               |█              |U+2588         |Solid rectangle
b               |⅟              |U+215F         |1/
c               |³              |U+00B3         |3/
d               |⁵              |U+2075         |5/
e               |⁷              |U+2077         |7/
f               |°              |U+00B0         |Degrees
g               |±              |U+00B1         |Plus or minus
h               |→              |U+2192         |Right arrow
i               |…              |U+2026         |Ellipsis (dots)
j               |÷              |U+00F7         |Divide by
k               |↓              |U+2193         |Down arrow
l               |⎺              |U+23BA         |Bar at scan 0
m               |⎺              |U+23BA         |Bar at scan 1
n               |⎻              |U+23BB         |Bar at scan 2
o               |⎻              |U+23BB         |Bar at scan 3
p               |⎼              |U+23BC         |Bar at scan 4
q               |⎼              |U+23BC         |Bar at scan 5
r               |⎽              |U+23BD         |Bar at scan 6
s               |⎽              |U+23BD         |Bar at scan 7
t               |₀              |U+2080         |Subscript 0
u               |₁              |U+2081         |Subscript 1
v               |₂              |U+2082         |Subscript 2
w               |₃              |U+2083         |Subscript 3
x               |₄              |U+2084         |Subscript 4
y               |₅              |U+2085         |Subscript 5
z               |₆              |U+2086         |Subscript 6
{               |₇              |U+2087         |Subscript 7
\|              |₈              |U+2088         |Subscript 8
}               |₉              |U+2089         |Subscript 9
\~              |¶              |U+00B6         |Paragraph

## UI/UX Design

There is no additional UI associated with this feature.

## Capabilities

### Accessibility

This should not impact accessibility any more than the existing escape sequences.

### Security

This should not introduce any new security issues.

### Reliability

This should not introduce any new reliability issues.

### Compatibility

This could be a breaking change for code that relies on the few existing VT52 commands being available without a mode change. However, that functionality is non-standard, and has not been around for that long. There is almost certainly more benefit in being able to implement the missing VT100 functionality than there is in retaining that non-standard behaviour.

### Performance, Power, and Efficiency

The additional mode flags and associated processing in the `StateMachine` and `TerminalInput` classes could have some performance impact, but that is unlikely to be significant.

## Potential Issues

The only negative impacts I can think of would be the potential for breaking changes, and the possible impact on performance, as discussed in the _Compatibility_ and _Performance_ sections above. But as with any new code, there is always the possibility of new bugs being introduced as well.

## Future considerations

As mentioned in the _Inspiration_ section, having the VT52 functionality isolated with a new mode would enable us to implement the VT100 Index (IND) escape sequence, which currently conflicts with the VT52 _Cursor Left_ command.

## Resources

* [VT52 Mode Control Sequences](https://vt100.net/docs/vt100-ug/chapter3.html#S3.3.5)
* [VT100 ANSI/VT52 Mode (DECANM)](https://vt100.net/docs/vt100-ug/chapter3.html#DECANM)
* [VT100 Index Sequence (IND)](https://vt100.net/docs/vt100-ug/chapter3.html#IND)
* [VTTEST Test Utility](https://invisible-island.net/vttest/)
* [DEC STD 070 Video Systems Reference Manual](https://archive.org/details/bitsavers_decstandar0VideoSystemsReferenceManualDec91_74264381)



